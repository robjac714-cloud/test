<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Reelly GPT-like Smart Chat (Auto Load + Index)</title>

  <style>
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Tahoma;background:#f5f5f7;padding:18px;color:#111827;}
    .wrap{max-width:1100px;margin:0 auto;}
    h1{margin:0 0 12px 0;font-size:20px}
    .status{margin:8px 0 14px;font-weight:800;line-height:1.6;}
    .muted{color:#6b7280;font-weight:700}
    .chatBox{background:#fff;border:1px solid #e5e7eb;border-radius:16px;padding:12px;box-shadow:0 10px 25px rgba(15,23,42,.06);}
    .messages{display:flex;flex-direction:column;gap:10px;max-height:320px;overflow:auto;padding:8px;border-radius:14px;background:#f9fafb;border:1px solid #eef2f7;}
    .msgRow{display:flex;gap:8px;align-items:flex-end;}
    .bubble{max-width:85%;padding:10px 12px;border-radius:14px;border:1px solid #e5e7eb;background:#fff;line-height:1.7;font-size:14px;white-space:pre-wrap;word-break:break-word;}
    .me{justify-content:flex-start}
    .me .bubble{background:#2563eb;color:#fff;border-color:#2563eb;border-bottom-right-radius:4px;}
    .bot{justify-content:flex-start}
    .bot .bubble{background:#fff;border-bottom-left-radius:4px;}
    .avatar{width:32px;height:32px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:900;background:#111827;color:#fff;flex:0 0 auto;}
    .avatar.meA{background:#2563eb}
    .composer{display:flex;gap:10px;align-items:center;margin-top:10px;flex-wrap:wrap;}
    input{flex:1;min-width:260px;padding:12px 12px;border-radius:12px;border:1px solid #e5e7eb;font-size:15px;outline:none;background:#fff;}
    button{padding:10px 14px;border-radius:12px;border:0;background:#2563eb;color:#fff;font-weight:800;cursor:pointer;}
    button:disabled{opacity:.6;cursor:not-allowed}
    .chips{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
    .chip{border:1px solid #e5e7eb;background:#fff;padding:8px 10px;border-radius:999px;cursor:pointer;font-weight:800;font-size:13px;color:#111827;}
    .chip:hover{box-shadow:0 6px 14px rgba(15,23,42,.08)}
    .suggestions{margin-top:10px;font-size:13px;color:#374151;line-height:1.7;}

    /* Results History */
    .history{margin-top:14px;display:flex;flex-direction:column;gap:14px;}
    .section{
      background:#fff;border:1px solid #e5e7eb;border-radius:16px;
      box-shadow:0 10px 25px rgba(15,23,42,.06); overflow:hidden;
    }
    .sectionHead{
      padding:10px 12px;border-bottom:1px solid #eef2f7;
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;
      background:#fafafa;
    }
    .sectionHead .q{font-weight:900}
    .sectionHead .sub{color:#6b7280;font-weight:800;font-size:12px}
    .grid{padding:12px;display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:16px;}
    .card{background:#fff;border-radius:14px;border:1px solid #e5e7eb;overflow:hidden;box-shadow:0 10px 25px rgba(15,23,42,.06);}
    .card img{width:100%;aspect-ratio:16/10;object-fit:cover;background:#e5e7eb;}
    .body{padding:12px}
    .title{font-weight:900;margin-bottom:6px}
    .meta{font-size:13px;color:#555;margin-bottom:6px}
    .why{margin-top:10px;font-size:12px;color:#374151;background:#f3f4f6;padding:8px 10px;border-radius:10px;line-height:1.6;border:1px solid #e5e7eb;}
    .empty{padding:20px;background:#fff;border:1px dashed #ccc;border-radius:14px;text-align:center;font-weight:900;}
  </style>
</head>

<body>
<div class="wrap">

  <h1>Ø´Ø§Øª Ø¨ÙˆØª Ø°ÙƒÙŠ (GPT-like) Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Reelly</h1>

  <div class="status" id="status">
    <span class="muted">Ù…Ø±Ø­Ø¨Ø§Ù‹ ğŸ‘‹</span> Ø§ÙƒØªØ¨ Ø·Ù„Ø¨Ùƒ Ø¨Ø¹Ø¯ Ù„Ø­Ø¸Ø§Øªâ€¦
  </div>

  <div class="chatBox">
    <div class="messages" id="messages"></div>

    <div class="composer">
      <input id="q" type="text" placeholder="Ù…Ø«Ø§Ù„: ØºØ±ÙØªÙŠÙ† Ø¯Ø¨ÙŠ Ù…Ø§Ø±ÙŠÙ†Ø§ ØªØ­Øª 2 Ù…Ù„ÙŠÙˆÙ†" disabled />
      <button id="ask" disabled>Ø§Ø¨Ø­Ø«</button>
    </div>

    <div class="chips" id="chips"></div>
    <div class="suggestions" id="suggestions"></div>
  </div>

  <div id="history" class="history"></div>

</div>

<script>
  // =========================
  // ğŸ”Œ API
  // =========================
  const API_BASE = "https://search-listings-production.up.railway.app/v1/properties";
  const API_KEY  = "reelly-80fd5f24-WLrF9bAxkGwYrUXFjrIyzNxRlzrB4kpH";

  // =========================
  // ğŸ§  Memory (Always Learn)
  // =========================
  const MEM_KEY = "reelly_gpt_memory_indexed_v3";
  function loadMemory(){
    try{
      const raw = localStorage.getItem(MEM_KEY);
      if(!raw) return {queryCounts:{}, areaCounts:{}, devCounts:{}, lastQueries:[]};
      const m = JSON.parse(raw);
      return {
        queryCounts: m.queryCounts || {},
        areaCounts: m.areaCounts || {},
        devCounts: m.devCounts || {},
        lastQueries: Array.isArray(m.lastQueries) ? m.lastQueries : []
      };
    }catch{
      return {queryCounts:{}, areaCounts:{}, devCounts:{}, lastQueries:[]};
    }
  }
  function saveMemory(mem){ localStorage.setItem(MEM_KEY, JSON.stringify(mem)); }
  let MEMORY = loadMemory();

  function bumpCount(map, key, inc=1){
    if(!key) return;
    map[key] = (map[key] || 0) + inc;
  }
  function pushLastQuery(q){
    q = String(q || "").trim();
    if(!q) return;
    MEMORY.lastQueries = MEMORY.lastQueries.filter(x => x !== q);
    MEMORY.lastQueries.unshift(q);
    MEMORY.lastQueries = MEMORY.lastQueries.slice(0, 10);
  }
  function topKeysByCount(obj, limit=4){
    const entries = Object.entries(obj || {});
    entries.sort((a,b)=> (b[1]||0)-(a[1]||0));
    return entries.slice(0, limit).map(([k])=>k);
  }

  // =========================
  // ğŸ§© Aliases
  // =========================
  const ALIASES = {
    areas: {
      "Ø§Ù„Ø®Ù„ÙŠØ¬ Ø§Ù„ØªØ¬Ø§Ø±ÙŠ": ["business bay","Ø¨Ø²Ù†Ø³ Ø¨Ø§ÙŠ","Ø§Ù„Ø®Ù„ÙŠØ¬ Ø§Ù„ØªØ¬Ø§Ø±ÙŠ","businessbay"],
      "Ø¯Ø¨ÙŠ Ù…Ø§Ø±ÙŠÙ†Ø§": ["dubai marina","Ù…Ø§Ø±ÙŠÙ†Ø§","Ø¯Ø¨ÙŠ Ù…Ø§Ø±ÙŠÙ†Ø§","marina"],
      "Ø¯Ø§ÙˆÙ† ØªØ§ÙˆÙ†": ["downtown","Ø¯Ø§ÙˆÙ† ØªØ§ÙˆÙ†","ÙˆØ³Ø· Ø¯Ø¨ÙŠ","downtown dubai"],
      "Ù‚Ø±ÙŠØ© Ø¬Ù…ÙŠØ±Ø§ Ø§Ù„Ø¯Ø§Ø¦Ø±ÙŠØ©": ["jvc","jumeirah village circle","Ù‚Ø±ÙŠØ© Ø¬Ù…ÙŠØ±Ø§","Ø¬ Ù Ø³ÙŠ","Ø¬ÙŠ ÙÙŠ Ø³ÙŠ"],
      "Ù‚Ø±ÙŠØ© Ø¬Ù…ÙŠØ±Ø§ Ø§Ù„Ù…Ø«Ù„Ø«Ø©": ["jvt","jumeirah village triangle","Ø¬ÙŠ ÙÙŠ ØªÙŠ"],
      "Ù†Ø®Ù„Ø© Ø¬Ù…ÙŠØ±Ø§": ["palm jumeirah","Ù†Ø®Ù„Ø© Ø¬Ù…ÙŠØ±Ø§","palm"],
      "Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠØ©": ["international city","Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠØ©"],
      "Ø¯Ø¨ÙŠ Ù‡ÙŠÙ„Ø²": ["dubai hills","Ø¯Ø¨ÙŠ Ù‡ÙŠÙ„Ø²","hills"],
    },
    developers: {
      "Ø§Ø¹Ù…Ø§Ø±": ["emaar","Ø§Ø¹Ù…Ø§Ø±","Ø¥Ø¹Ù…Ø§Ø±"],
      "Ø¯Ø§Ù…Ø§Ùƒ": ["damac","Ø¯Ø§Ù…Ø§Ùƒ"],
      "Ù†Ø®ÙŠÙ„": ["nakheel","Ù†Ø®ÙŠÙ„"],
      "Ù…Ø±Ø§Ø³": ["meraas","Ù…Ø±Ø§Ø³"],
      "Ø¹Ø²ÙŠØ²ÙŠ": ["azizi","Ø¹Ø²ÙŠØ²ÙŠ"],
      "Ø¯Ø§Ù†ÙˆØ¨": ["danube","Ø¯Ø§Ù†ÙˆØ¨"],
      "Ø´ÙˆØ¨Ø§": ["sobha","Ø´ÙˆØ¨Ø§"],
      "Ù…Ø§Ø¬": ["mag","Ù…Ø§Ø¬"],
    }
  };

  // =========================
  // ğŸ§± DOM
  // =========================
  const statusEl = document.getElementById("status");
  const qEl = document.getElementById("q");
  const askBtn = document.getElementById("ask");
  const messagesEl = document.getElementById("messages");
  const chipsEl = document.getElementById("chips");
  const suggestionsEl = document.getElementById("suggestions");
  const historyEl = document.getElementById("history");

  // =========================
  // ğŸ—ƒï¸ Data cache + INDEX
  // =========================
  let ALL_PROJECTS = [];
  let INDEX = [];
  let READY = false;

  // =========================
  // ğŸ§  Conversation context (links queries)
  // =========================
  let LAST_CONTEXT = null; // { filters, query }

  // =========================
  // Helpers
  // =========================
  function escapeHtml(str){
    return String(str ?? "")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  function normalizeArabic(s){
    return String(s || "")
      .toLowerCase()
      .replaceAll("Ø£","Ø§").replaceAll("Ø¥","Ø§").replaceAll("Ø¢","Ø§")
      .replaceAll("Ù‰","ÙŠ").replaceAll("Ø©","Ù‡")
      .replaceAll("Ø¤","Ùˆ").replaceAll("Ø¦","ÙŠ")
      .replaceAll(/[\u064B-\u065F]/g, "")
      .replaceAll(/[^\p{L}\p{N}\s.]/gu, " ")
      .replaceAll(/\s+/g, " ")
      .trim();
  }

  function normalizeItems(data){
    if(Array.isArray(data)) return data;
    if(Array.isArray(data?.items)) return data.items;
    if(Array.isArray(data?.data)) return data.data;
    if(Array.isArray(data?.results)) return data.results;
    if(Array.isArray(data?.properties)) return data.properties;
    return [];
  }

  function getImage(item){
    if(item?.cover_image_url){
      try{
        const parsed = JSON.parse(item.cover_image_url);
        if(parsed?.url) return parsed.url;
      }catch{}
      if(String(item.cover_image_url).startsWith("http")) return item.cover_image_url;
    }
    return "https://dummyimage.com/800x500/e5e7eb/111827&text=No+Image";
  }

  function getPriceNumber(item){
    const p = item?.min_price ?? item?.starting_price ?? item?.price_from ?? item?.price;
    if(p == null) return null;
    const pn = Number(String(p).replaceAll(",",""));
    return Number.isFinite(pn) ? pn : null;
  }

  function getBedsNumber(item){
    const b = item?.bedrooms ?? item?.min_bedrooms ?? item?.beds ?? item?.min_beds;
    if(b == null) return null;
    const bn = Number(String(b).replaceAll(",",""));
    return Number.isFinite(bn) ? bn : null;
  }

  function itemTextForIndex(item){
    return normalizeArabic([
      item?.name, item?.title,
      item?.developer, item?.developer_name,
      item?.region, item?.area, item?.location,
      item?.city, item?.community, item?.district,
      item?.type
    ].filter(Boolean).join(" "));
  }

  function tokenizeText(text){
    const stop = new Set([
      "ÙÙŠ","Ø¨Ø§Ù„","Ø¨Ø§Ù„Ù€","Ù…Ù†","Ø§Ù„Ù‰","Ùˆ","Ø§Ùˆ","Ø§Ù‚Ù„","ØªØ­Øª","Ø§ÙƒØ«Ø±","ÙÙˆÙ‚","Ø³Ø¹Ø±",
      "ØºØ±Ù","ØºØ±ÙØ©","Ø´Ù‚Ù‡","Ø´Ù‚Ø©","apartment","villa","ØªØ§ÙˆÙ†Ù‡Ø§ÙˆØ³","ØªØ§ÙˆÙ†","Ø§Ù„Ù…Ø·ÙˆØ±","developer"
    ]);
    return text.split(" ").filter(Boolean).filter(w => w.length >= 2 && !stop.has(w));
  }

  function buildIndex(items){
    INDEX = items.map(it=>{
      const text = itemTextForIndex(it);
      const words = new Set(tokenizeText(text));
      const id = it?.id ?? it?._id ?? it?.uuid ?? null;
      return {
        id: id != null ? String(id) : null,
        item: it,
        text,
        words,
        price: getPriceNumber(it),
        beds: getBedsNumber(it)
      };
    });
  }

  // =========================
  // Chat UI
  // =========================
  function addMsg(role, text){
    const row = document.createElement("div");
    row.className = "msgRow " + (role === "me" ? "me" : "bot");

    const avatar = document.createElement("div");
    avatar.className = "avatar " + (role === "me" ? "meA" : "");
    avatar.textContent = role === "me" ? "Ø£" : "ğŸ¤–";

    const bubble = document.createElement("div");
    bubble.className = "bubble";
    bubble.textContent = text;

    if(role === "me"){ row.appendChild(bubble); row.appendChild(avatar); }
    else { row.appendChild(avatar); row.appendChild(bubble); }

    messagesEl.appendChild(row);
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  // =========================
  // Seeded shuffle
  // =========================
  function hashString(str){
    str = String(str || "");
    let h = 2166136261;
    for(let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function seededShuffle(arr, seed){
    let a = arr.slice();
    let s = seed >>> 0;
    function rnd(){
      s = (Math.imul(1664525, s) + 1013904223) >>> 0;
      return s / 4294967296;
    }
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(rnd() * (i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // =========================
  // NLP
  // =========================
  function levenshtein(a,b){
    a = a || ""; b = b || "";
    const m=a.length,n=b.length;
    const dp = Array.from({length:m+1},()=>Array(n+1).fill(0));
    for(let i=0;i<=m;i++) dp[i][0]=i;
    for(let j=0;j<=n;j++) dp[0][j]=j;
    for(let i=1;i<=m;i++){
      for(let j=1;j<=n;j++){
        const c = a[i-1]===b[j-1]?0:1;
        dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+c);
      }
    }
    return dp[m][n];
  }

  function fuzzyTokenMatch(wordsSet, token){
    if(wordsSet.has(token)) return true;
    if(token.length < 4) return false;
    for(const w of wordsSet){
      if(Math.abs(w.length - token.length) > 3) continue;
      if(levenshtein(w, token) <= 1) return true;
    }
    return false;
  }

  function moneyToNumber(numStr, unit){
    const n = Number(String(numStr).replaceAll(",",""));
    if(!Number.isFinite(n)) return null;
    const u = (unit || "").toLowerCase();
    if(u.includes("Ù…Ù„ÙŠÙˆÙ†") || u === "m") return Math.round(n * 1_000_000);
    if(u.includes("Ø§Ù„Ù") || u === "k") return Math.round(n * 1_000);
    return Math.round(n);
  }

  function parseMoneySmart(q){
    const t = normalizeArabic(q);

    let between = t.match(/Ø¨ÙŠÙ†\s+([\d.]+)\s*(Ù…Ù„ÙŠÙˆÙ†|m|Ø§Ù„Ù|k)?\s+Ùˆ\s+([\d.]+)\s*(Ù…Ù„ÙŠÙˆÙ†|m|Ø§Ù„Ù|k)?/);
    if(between){
      const a = moneyToNumber(between[1], between[2]);
      const b = moneyToNumber(between[3], between[4]);
      if(a && b) return {min: Math.min(a,b), max: Math.max(a,b)};
    }

    let fromTo = t.match(/Ù…Ù†\s+([\d.]+)\s*(Ù…Ù„ÙŠÙˆÙ†|m|Ø§Ù„Ù|k)?\s+(Ø§Ù„Ù‰|Ù„)\s+([\d.]+)\s*(Ù…Ù„ÙŠÙˆÙ†|m|Ø§Ù„Ù|k)?/);
    if(fromTo){
      const a = moneyToNumber(fromTo[1], fromTo[2]);
      const b = moneyToNumber(fromTo[4], fromTo[5]);
      if(a && b) return {min: Math.min(a,b), max: Math.max(a,b)};
    }

    if(t.includes("Ø§Ù‚Ù„") || t.includes("ØªØ­Øª") || t.includes("Ù…Ø§ÙƒØ³") || t.includes("Ø­Ø¯")){
      const m = t.match(/([\d.]+)\s*(Ù…Ù„ÙŠÙˆÙ†|m|Ø§Ù„Ù|k)?/);
      if(m){
        const v = moneyToNumber(m[1], m[2]);
        if(v) return {min:null, max:v};
      }
    }

    if(t.includes("Ø§ÙƒØ«Ø±") || t.includes("ÙÙˆÙ‚") || t.includes("Ø§Ø¨ØªØ¯Ø§Ø¡") || t.includes("Ù…ÙŠÙ†ÙŠÙ…Ù…")){
      const m = t.match(/([\d.]+)\s*(Ù…Ù„ÙŠÙˆÙ†|m|Ø§Ù„Ù|k)?/);
      if(m){
        const v = moneyToNumber(m[1], m[2]);
        if(v) return {min:v, max:null};
      }
    }

    return {min:null, max:null};
  }

  function parseBedroomsSmart(q){
    const t = normalizeArabic(q);
    if(t.includes("Ø³ØªÙˆØ¯ÙŠÙˆ") || t.includes("Ø§Ø³ØªÙˆØ¯ÙŠÙˆ") || t.includes("studio")) return 0;
    if(t.includes("ØºØ±ÙØªÙŠÙ†")) return 2;
    if(t.includes("Ø«Ù„Ø§Ø«")) return 3;
    if(t.includes("Ø§Ø±Ø¨Ø¹") || t.includes("Ø§Ø±Ø¨Ø¹Ù‡")) return 4;
    if(t.includes("Ø®Ù…Ø³")) return 5;

    const m = t.match(/(\d+)\s*(ØºØ±Ù|ØºØ±ÙØ©|bed|br)/i);
    if(m) return Number(m[1]);

    const m2 = t.match(/(\d+)\s*bhk/i);
    if(m2) return Number(m2[1]);

    return null;
  }

  function parseType(q){
    const t = normalizeArabic(q);
    const types = [
      {key:"apartment", words:["Ø´Ù‚Ù‡","Ø´Ù‚Ø©","apartment","apt"]},
      {key:"villa", words:["ÙÙŠÙ„Ø§","villa"]},
      {key:"townhouse", words:["ØªØ§ÙˆÙ†Ù‡Ø§ÙˆØ³","ØªØ§ÙˆÙ†","townhouse"]},
      {key:"penthouse", words:["Ø¨Ù†ØªÙ‡Ø§ÙˆØ³","penthouse"]},
      {key:"duplex", words:["Ø¯ÙˆØ¨Ù„ÙƒØ³","duplex"]},
    ];
    for(const tp of types){
      if(tp.words.some(w => t.includes(normalizeArabic(w)))) return tp.key;
    }
    return null;
  }

  function extractAllAliases(q, dict){
    const t = normalizeArabic(q);
    const found = [];
    for(const canonical in dict){
      const arr = dict[canonical];
      for(const w of arr){
        if(t.includes(normalizeArabic(w))){
          found.push(canonical);
          break;
        }
      }
    }
    return [...new Set(found)];
  }

  function tokenizeQuery(q){ return tokenizeText(normalizeArabic(q)); }

  function humanizeFilters(f){
    const parts = [];
    if(f.areas?.length) parts.push(`Ø§Ù„Ù…Ù†Ø·Ù‚Ø©: ${f.areas.join(" Ø£Ùˆ ")}`);
    if(f.developers?.length) parts.push(`Ø§Ù„Ù…Ø·ÙˆØ±: ${f.developers.join(" Ø£Ùˆ ")}`);
    if(f.beds != null) parts.push(`ØºØ±Ù: ${f.beds===0?"Ø³ØªÙˆØ¯ÙŠÙˆ":f.beds}`);
    if(f.money?.min != null) parts.push(`Ø³Ø¹Ø± Ù…Ù†: ${f.money.min.toLocaleString()}`);
    if(f.money?.max != null) parts.push(`Ø³Ø¹Ø± Ø¥Ù„Ù‰: ${f.money.max.toLocaleString()}`);
    if(f.type) parts.push(`Ù†ÙˆØ¹: ${f.type}`);
    if(f.tokens?.length) parts.push(`ÙƒÙ„Ù…Ø§Øª: ${f.tokens.join("ØŒ ")}`);
    return parts;
  }

  // =========================
  // âœ… Merge context (smart linking)
  // =========================
  function mergeWithContext(currentFilters, lastFilters){
    if(!lastFilters) return currentFilters;

    const merged = JSON.parse(JSON.stringify(currentFilters));

    // ÙˆØ±Ø§Ø«Ø© Ø°ÙƒÙŠØ© ÙÙ‚Ø· Ø¥Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø§ Ø°ÙƒØ± Ø§Ù„Ø´ÙŠ Ø¨Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ
    if(merged.areas.length === 0 && lastFilters.areas?.length) merged.areas = lastFilters.areas.slice();
    if(merged.developers.length === 0 && lastFilters.developers?.length) merged.developers = lastFilters.developers.slice();
    if(merged.beds == null && lastFilters.beds != null) merged.beds = lastFilters.beds;
    if((merged.money?.min == null && merged.money?.max == null) && lastFilters.money){
      merged.money = { ...lastFilters.money };
    }
    if(!merged.type && lastFilters.type) merged.type = lastFilters.type;

    // tokens: Ø§Ø¯Ù…Ø¬ (Ø¨Ø¯ÙˆÙ† ØªÙƒØ±Ø§Ø±)
    const tset = new Set([...(lastFilters.tokens||[]), ...(merged.tokens||[])]);
    merged.tokens = [...tset];

    return merged;
  }

  // =========================
  // âœ… Indexed Search (scoring)
  // =========================
  function searchWithFilters(nq, filters){
    let followUp = null;
    if(filters.areas.length > 1){
      followUp = `Ù„Ø§Ø­Ø¸Øª Ø£ÙƒØªØ± Ù…Ù† Ù…Ù†Ø·Ù‚Ø©: (${filters.areas.join("ØŒ ")}). ØªØ®ØªØ§Ø± ÙˆØ­Ø¯Ø© ÙÙŠÙ‡Ù…ØŸ`;
    }

    const scored = INDEX.map(node=>{
      let score = 0;
      const reasons = [];

      // areas
      if(filters.areas.length){
        let hit=false, hitName=null;
        for(const a of filters.areas){
          const tok = normalizeArabic(a);
          if(node.text.includes(tok) || fuzzyTokenMatch(node.words, tok)){ hit=true; hitName=a; break; }
        }
        if(hit){ score += 12; reasons.push(`Ù…Ù†Ø·Ù‚Ø©: ${hitName}`); }
        else score -= 4;
      }

      // developers
      if(filters.developers.length){
        let hit=false, hitName=null;
        for(const d of filters.developers){
          const tok = normalizeArabic(d);
          if(node.text.includes(tok) || fuzzyTokenMatch(node.words, tok)){ hit=true; hitName=d; break; }
        }
        if(hit){ score += 10; reasons.push(`Ù…Ø·ÙˆØ±: ${hitName}`); }
        else score -= 3;
      }

      // tokens
      if(filters.tokens.length){
        let hits = 0;
        for(const t of filters.tokens){
          if(fuzzyTokenMatch(node.words, t)){ score += 3; hits++; }
        }
        if(hits) reasons.push(`ÙƒÙ„Ù…Ø§Øª: ${hits}/${filters.tokens.length}`);
        else score -= 1;
      }

      // beds
      if(filters.beds != null){
        if(node.beds != null && Number(node.beds) === filters.beds){
          score += 8; reasons.push(`ØºØ±Ù: ${filters.beds===0?"Ø³ØªÙˆØ¯ÙŠÙˆ":filters.beds}`);
        }else{
          score -= 2;
        }
      }

      // price
      if(filters.money?.max != null){
        if(node.price != null && node.price <= filters.money.max){ score += 7; reasons.push("Ø¶Ù…Ù† Ø³Ù‚Ù Ø§Ù„Ø³Ø¹Ø±"); }
        else score -= 3;
      }
      if(filters.money?.min != null){
        if(node.price != null && node.price >= filters.money.min){ score += 2; reasons.push("Ø£Ø¹Ù„Ù‰ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰"); }
        else score -= 2;
      }

      // type
      if(filters.type){
        if(node.text.includes(filters.type)){ score += 2; reasons.push("Ù†ÙˆØ¹ Ù…Ù†Ø§Ø³Ø¨"); }
      }

      return { node, score, why: reasons.join("ØŒ ") || "Ø£Ù‚Ø±Ø¨ Ù†ØªÙŠØ¬Ø© Ø­Ø³Ø¨ Ø§Ù„ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ø¹Ø§Ù…" };
    });

    scored.sort((a,b)=>b.score-a.score);

    let picked = scored.filter(x=>x.score > 0);
    let note = null;

    if(picked.length === 0){
      const seed = hashString(nq);
      picked = seededShuffle(scored, seed).slice(0, 20)
        .map(x=>({ ...x, why:"Ù…Ø·Ø§Ø¨Ù‚Ø© Ø¶Ø¹ÙŠÙØ© â€” Ø¹Ø±Ø¶Øª Ø®ÙŠØ§Ø±Ø§Øª Ø¹Ø§Ù…Ø©" }));
      note = "Ù„ØªÙƒÙˆÙ† Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø£Ø¯Ù‚: Ø­Ø¯Ù‘Ø¯ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø£Ùˆ Ø§Ù„Ù…ÙŠØ²Ø§Ù†ÙŠØ© Ø£Ùˆ Ø¹Ø¯Ø¯ Ø§Ù„ØºØ±Ù.";
    }else{
      const bestScore = picked[0].score;
      if(bestScore >= 10) picked = picked.slice(0, 20);
      else if(bestScore >= 4){ picked = picked.slice(0, 30); note = "Ù‡Ø§ÙŠ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø£Ù‚Ø±Ø¨ Ù„Ø·Ù„Ø¨Ùƒ."; }
      else { picked = seededShuffle(picked, hashString(nq)).slice(0, 40); note = "Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø© Ø¶Ø¹ÙŠÙØ© Ù†Ø³Ø¨ÙŠÙ‹Ø§ØŒ ÙÙˆØ³Ù‘Ø¹Øª Ø§Ù„Ù†Ø·Ø§Ù‚ Ø´ÙˆÙŠ."; }
    }

    const suggestions = [];
    if(filters.areas.length === 0) suggestions.push("Ø­Ø¯Ø¯ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© (Ù…Ø«Ø§Ù„: Ø¯Ø¨ÙŠ Ù…Ø§Ø±ÙŠÙ†Ø§ / Ø§Ù„Ø®Ù„ÙŠØ¬ Ø§Ù„ØªØ¬Ø§Ø±ÙŠ)");
    if(filters.beds == null) suggestions.push("Ø­Ø¯Ø¯ Ø¹Ø¯Ø¯ Ø§Ù„ØºØ±Ù (Ù…Ø«Ø§Ù„: ØºØ±ÙØªÙŠÙ† / 2br)");
    if(filters.money?.max == null && filters.money?.min == null) suggestions.push("Ø­Ø¯Ø¯ Ø§Ù„Ù…ÙŠØ²Ø§Ù†ÙŠØ© (Ù…Ø«Ø§Ù„: ØªØ­Øª 2 Ù…Ù„ÙŠÙˆÙ† / Ø¨ÙŠÙ† 1 Ùˆ 2 Ù…Ù„ÙŠÙˆÙ†)");
    if(filters.developers.length === 0) suggestions.push("Ø¥Ø°Ø§ Ø¨Ø¯Ùƒ Ù…Ø·ÙˆØ± Ù…Ø¹ÙŠÙ‘Ù† (Ù…Ø«Ø§Ù„: Ø§Ø¹Ù…Ø§Ø± / Ø¯Ø§Ù…Ø§Ùƒ)");

    const metaById = new Map();
    for(const x of picked){
      const id = x.node.id != null ? String(x.node.id) : null;
      if(id) metaById.set(id, x.why);
    }

    return {
      results: picked.map(x=>x.node.item),
      metaById,
      filters,
      note,
      question: followUp,
      suggestions
    };
  }

  function searchIndexed(query){
    const raw = String(query||"").trim();
    const nq = normalizeArabic(raw);

    // parse current filters
    const current = {
      beds: parseBedroomsSmart(nq),
      money: parseMoneySmart(nq),
      type: parseType(nq),
      areas: extractAllAliases(nq, ALIASES.areas),
      developers: extractAllAliases(nq, ALIASES.developers),
      tokens: tokenizeQuery(nq)
    };

    // âœ… merge with last context (smart linking)
    const merged = mergeWithContext(current, LAST_CONTEXT?.filters || null);

    // search with merged filters
    const out = searchWithFilters(nq, merged);

    // update context
    LAST_CONTEXT = { query: raw, filters: merged };

    return out;
  }

  // =========================
  // Always Learn
  // =========================
  function learnAlways(query, out){
    query = String(query || "").trim();
    if(!query) return;
    bumpCount(MEMORY.queryCounts, query, 1);
    pushLastQuery(query);
    out?.filters?.areas?.forEach(a => bumpCount(MEMORY.areaCounts, a, 1));
    out?.filters?.developers?.forEach(d => bumpCount(MEMORY.devCounts, d, 1));
    saveMemory(MEMORY);
  }

  // =========================
  // Chips + Suggestions
  // =========================
  function setChips(list){
    chipsEl.innerHTML = "";
    list.forEach(text=>{
      const btn = document.createElement("div");
      btn.className = "chip";
      btn.textContent = text;
      btn.addEventListener("click", ()=>{
        if(qEl.disabled) return;
        const current = qEl.value.trim();
        qEl.value = current ? (current + " " + text) : text;
        qEl.focus();
      });
      chipsEl.appendChild(btn);
    });
  }

  function refreshChips(){
    const learnedAreas = topKeysByCount(MEMORY.areaCounts, 3);
    const learnedDevs  = topKeysByCount(MEMORY.devCounts, 3);
    const learnedQs    = (MEMORY.lastQueries || []).slice(0, 2);
    const base = ["ØºØ±ÙØªÙŠÙ†", "ØªØ­Øª 2 Ù…Ù„ÙŠÙˆÙ†", "Ø§Ù„Ø®Ù„ÙŠØ¬ Ø§Ù„ØªØ¬Ø§Ø±ÙŠ", "Ø¯Ø¨ÙŠ Ù…Ø§Ø±ÙŠÙ†Ø§", "Ù…Ø·ÙˆØ± Ø§Ø¹Ù…Ø§Ø±"];

    const dynamic = [];
    learnedAreas.forEach(a => dynamic.push(a));
    learnedDevs.forEach(d => dynamic.push("Ù…Ø·ÙˆØ± " + d));
    learnedQs.forEach(q => dynamic.push(q));

    const uniq = [];
    const seen = new Set();
    for(const x of [...dynamic, ...base]){
      const k = normalizeArabic(x);
      if(seen.has(k)) continue;
      seen.add(k);
      uniq.push(x);
    }
    setChips(uniq.slice(0, 10));
  }

  function showSuggestions(out){
    suggestionsEl.innerHTML = "";
    const parts = [];
    const hotAreas = topKeysByCount(MEMORY.areaCounts, 4);
    const hotDevs  = topKeysByCount(MEMORY.devCounts, 4);

    if(out?.filters){
      const understood = humanizeFilters(out.filters);
      if(understood.length) parts.push(`<b>ÙÙ‡Ù…Øª Ø·Ù„Ø¨Ùƒ:</b> ${escapeHtml(understood.join(" | "))}`);
    }
    if(out?.note) parts.push(`<b>Ù…Ù„Ø§Ø­Ø¸Ø©:</b> ${escapeHtml(out.note)}`);
    if(out?.question) parts.push(`<b>Ø³Ø¤Ø§Ù„:</b> ${escapeHtml(out.question)}`);
    if(out?.suggestions?.length) parts.push(`<b>Ù„ØªØ¯Ù‚ÙŠÙ‚ Ø£ÙƒØ«Ø±:</b> ${escapeHtml(out.suggestions.slice(0,3).join(" â€” "))}`);
    if(hotAreas.length) parts.push(`<b>Ù…Ù†Ø§Ø·Ù‚ Ù…Ø·Ù„ÙˆØ¨Ø© ÙƒØ«ÙŠØ±Ù‹Ø§:</b> ${escapeHtml(hotAreas.join("ØŒ "))}`);
    if(hotDevs.length) parts.push(`<b>Ù…Ø·ÙˆÙ‘Ø±ÙŠÙ† Ù…Ø·Ù„ÙˆØ¨ÙŠÙ† ÙƒØ«ÙŠØ±Ù‹Ø§:</b> ${escapeHtml(hotDevs.join("ØŒ "))}`);

    suggestionsEl.innerHTML = parts.map(p=>`<div style="margin-top:6px">${p}</div>`).join("");
  }

  // =========================
  // âœ… Render results as history (append, not replace)
  // =========================
  function renderCardsHistory(queryText, items, metaById=null, out=null){
    const section = document.createElement("div");
    section.className = "section";

    const head = document.createElement("div");
    head.className = "sectionHead";

    const left = document.createElement("div");
    left.innerHTML = `<div class="q">ğŸ§¾ ${escapeHtml(queryText)}</div>
                      <div class="sub">${escapeHtml((out?.note || ""))}</div>`;

    const right = document.createElement("div");
    const understood = out?.filters ? humanizeFilters(out.filters).join(" | ") : "";
    right.innerHTML = `<div class="sub">${escapeHtml(understood)}</div>`;

    head.appendChild(left);
    head.appendChild(right);

    const grid = document.createElement("div");
    grid.className = "grid";

    if(!items.length){
      grid.innerHTML = `<div class="empty">Ù…Ø§ ÙÙŠ Ù†ØªØ§Ø¦Ø¬ Ù…Ø·Ø§Ø¨Ù‚Ø© Ø­Ø§Ù„ÙŠØ§Ù‹.</div>`;
    }else{
      const frag = document.createDocumentFragment();
      items.forEach(item=>{
        const card = document.createElement("div");
        card.className="card";

        const name = escapeHtml(item?.name || item?.title || "Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…");
        const developer = escapeHtml(item?.developer || item?.developer_name || "-");
        const minPrice = escapeHtml(item?.min_price || item?.starting_price || item?.price_from || "-");
        const region = escapeHtml(item?.region || item?.area || item?.location || "-");
        const img = getImage(item);

        const id = item?.id ?? item?._id ?? item?.uuid ?? null;
        const why = metaById && id != null ? metaById.get(String(id)) : null;

        card.innerHTML = `
          <img src="${img}" alt="">
          <div class="body">
            <div class="title">${name}</div>
            <div class="meta">Ø§Ù„Ù…Ø·ÙˆØ±: ${developer}</div>
            <div class="meta">Ø§Ù„Ø³Ø¹Ø± Ù…Ù†: ${minPrice}</div>
            <div class="meta">Ø§Ù„Ù…Ù†Ø·Ù‚Ø©: ${region}</div>
            ${why ? `<div class="why">Ù„ÙŠØ´ Ø§Ù†Ø¹Ø±Ø¶ØªØŸ ${escapeHtml(why)}</div>` : ``}
          </div>
        `;
        frag.appendChild(card);
      });
      grid.appendChild(frag);
    }

    section.appendChild(head);
    section.appendChild(grid);

    // âœ… append new section (keep old results)
    historyEl.prepend(section);
  }

  // =========================
  // Auto load + build index
  // =========================
  async function autoPrepare(){
    addMsg("bot",
      "Ø£Ù‡Ù„Ù‹Ø§ ÙÙŠÙƒ ğŸ‘‹\n" +
      "Ø§ÙƒØªØ¨ Ø·Ù„Ø¨Ùƒ Ù…Ø«Ù„:\n" +
      "â€¢ ØºØ±ÙØªÙŠÙ† Ø¯Ø¨ÙŠ Ù…Ø§Ø±ÙŠÙ†Ø§ ØªØ­Øª 2 Ù…Ù„ÙŠÙˆÙ†\n" +
      "â€¢ Ù…Ø·ÙˆØ± Ø§Ø¹Ù…Ø§Ø± Ø§Ù„Ø®Ù„ÙŠØ¬ Ø§Ù„ØªØ¬Ø§Ø±ÙŠ\n\n" +
      "Ø±Ø­ ØªØµÙŠØ± Ø¬Ø§Ù‡Ø² Ø¨Ø¹Ø¯ Ù„Ø­Ø¸Ø§Øª."
    );

    try{
      const url = `${API_BASE}?per_page=9999&page=1`;
      const res = await fetch(url, { headers:{ "X-API-Key": API_KEY, "accept":"application/json" } });

      const text = await res.text();
      let data = {};
      try{ data = JSON.parse(text); }catch{}

      const items = normalizeItems(data);

      if(!res.ok){
        statusEl.textContent = `ØªØ¹Ø°Ø± ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Status: ${res.status})`;
        addMsg("bot", "ØµØ§Ø± ÙÙŠ Ù…Ø´ÙƒÙ„Ø© Ø¨Ø§Ù„Ø§ØªØµØ§Ù„. Ø¬Ø±Ù‘Ø¨ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©.");
        return;
      }

      ALL_PROJECTS = items;
      buildIndex(ALL_PROJECTS);
      READY = true;

      qEl.disabled = false;
      askBtn.disabled = false;
      statusEl.textContent = "Ø¬Ø§Ù‡Ø² âœ… Ø§ÙƒØªØ¨ Ø§Ø³ØªØ¹Ù„Ø§Ù…Ùƒ.";

      addMsg("bot", `ØªÙ…Ø§Ù… âœ… Ø¬Ø§Ù‡Ø² Ù„Ù„Ø¨Ø­Ø«. (Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹: ${ALL_PROJECTS.length})`);
      refreshChips();
      showSuggestions(null);

    }catch(e){
      statusEl.textContent = "ØªØ¹Ø°Ø± ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Ø®Ø·Ø£ Ø¨Ø§Ù„Ø´Ø¨ÙƒØ©)";
      addMsg("bot", "ØµØ§Ø± Ø®Ø·Ø£ Ø¨Ø§Ù„Ø´Ø¨ÙƒØ©. Ø¬Ø±Ù‘Ø¨ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©.");
    }
  }

  // =========================
  // Ask / Search
  // =========================
  function handleAsk(){
    if(!READY){
      addMsg("bot", "Ù„Ø³Ù‡ Ù„Ø­Ø¸Ø§Øªâ€¦");
      return;
    }

    const query = qEl.value.trim();
    if(!query){
      addMsg("bot", "Ø§ÙƒØªØ¨ Ø·Ù„Ø¨Ùƒ Ù…Ø«Ù„: ØºØ±ÙØªÙŠÙ† Ø¯Ø¨ÙŠ Ù…Ø§Ø±ÙŠÙ†Ø§ ØªØ­Øª 2 Ù…Ù„ÙŠÙˆÙ†");
      return;
    }

    addMsg("me", query);

    const out = searchIndexed(query);

    learnAlways(query, out);
    refreshChips();

    const understood = humanizeFilters(out.filters || {});
    const msg =
      `ØªÙ…Ø§Ù… âœ…\n` +
      `Ø±Ø­ Ø£Ø¹Ø±Ø¶ Ø£ÙØ¶Ù„ ${out.results.length} Ù†ØªÙŠØ¬Ø©.\n` +
      (understood.length ? `ÙÙ‡Ù…Øª: ${understood.join(" | ")}\n` : "") +
      (out.note ? `Ù…Ù„Ø§Ø­Ø¸Ø©: ${out.note}\n` : "") +
      (out.question ? `Ø³Ø¤Ø§Ù„ Ø³Ø±ÙŠØ¹: ${out.question}\n` : "");

    addMsg("bot", msg);
    showSuggestions(out);

    // âœ… add as history section (no wiping)
    renderCardsHistory(query, out.results, out.metaById, out);

    qEl.value = "";
    qEl.focus();
  }

  askBtn.addEventListener("click", handleAsk);
  qEl.addEventListener("keydown", (e)=>{ if(e.key === "Enter") handleAsk(); });

  document.addEventListener("DOMContentLoaded", autoPrepare);
</script>

</body>
</html>
